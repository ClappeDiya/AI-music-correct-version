---
description: Guide
globs: 
alwaysApply: false
---
##Operating environment:
- Windows.
Use powershell command
# Your rule content

- ## 1. Development Philosophy

- **Write Clean and Maintainable Code**  
  Keep your codebase organized and readable in both Django and Next.js.

- **Follow SOLID Principles**  
  Ensure each part of your system (backend or frontend) is modular and easy to extend.

- **Separate Concerns**  
  Let Django handle backend logic (data models, authentication, etc.) while Next.js + shadcn/ui focuses on the frontend.

- **Emphasize Type Safety**  
  For the frontend, leverage TypeScript to reduce runtime errors.

- **Component-Driven Development**  
  In the frontend, design reusable components using shadcn/ui and React.

---

## 2. Code Implementation Guidelines

### 2.1 Planning Phase

- **Step-by-Step Planning**  
  Break down each feature: consider the backend models, API endpoints, and frontend components.

- **Detailed Pseudocode**  
  Outline business logic on the Django side and data flow on the React side before implementing.

- **Document Architecture**  
  Create a clear mental model of how data flows from the Django backend to the Next.js frontend.

- **Consider Edge Cases**  
  Handle errors gracefully in both the Python backend (exceptions, validations) and the React frontend (component-level error states).

### 2.2 Code Style

#### Python (Django) Code Style

- **Follow PEP 8**  
  - snake_case for variable and function names.  
  - PascalCase for classes.  
  - UPPERCASE for constants.  
- **Use 4 Spaces for Indentation**  
  Standard for Python.
- **Line Length**  
  Aim for 79–100 characters per line (PEP 8 suggests 79).
- **Organize Imports**  
  Use `isort` or manually group imports (standard library, third-party, local) for clarity.

#### JavaScript/TypeScript (Next.js + shadcn/ui) Code Style

- **Indentation**  
  Use tabs (or 2 spaces if your team prefers—just be consistent).
- **Strings**  
  Use single quotes (avoid escaping unless necessary).
- **Semicolons**  
  Omit unless required for disambiguation.
- **Unused Variables**  
  Eliminate them—keep code clean.
- **Spacing**  
  - Space after keywords, around operators, and after commas.  
  - Keep `else` on the same line as closing braces.
- **Equality**  
  Always use strict equality (`===`).
- **Line Length**  
  Keep to around 80 characters when possible.
- **Trailing Commas**  
  Use trailing commas in multiline objects, arrays, and imports.

---

## 3. Naming Conventions
### Django
- Project/App Names: lower_snake
- Model Names: PascalCase
- Field Names: snake_case
- Class-based Views: PascalCase
- Function-based Views: snake_case
- URL Names: snake_case
- Template Names: lower_snake
- Settings: UPPER_SNAKE

### Next.js
- Directory Names: lower_snake
- Component Names: PascalCase
- File Names: PascalCase 
- Variables/Functions: camelCase
- Props/State: camelCase
- Custom Hooks: usePrefix
- CSS (Tailwind): kebab-case
- shadcn/ui Components: PascalCase
- Environment Variables: UPPER_SNAKE

#### Specific Naming Patterns (Next.js/TypeScript)

- **Event Handlers**  
  Prefix with “handle” (e.g., `handleClick`, `handleSubmit`).
- **Boolean Variables**  
  Use verbs (e.g., `isLoading`, `hasError`).
- **Custom Hooks**  
  Prefix with “use” (e.g., `useAuth`, `useForm`).
- **Allowed Abbreviations**  
  `err`, `req`, `res`, `props`, `ref`.

---

## 4. Django Best Practices

### 4.1 Project Structure

- **Apps**  
  Each Django app should have a clear responsibility (e.g., `users`, `products`, `orders`).

- **Models**  
  Keep them concise; each model should represent a single entity.

- **Views**  
  Keep logic minimal—use services/helpers to handle complex business logic.

- **URLs**  
  Group related endpoints by app; use `include` to keep routing organized.

### 4.2 Django-Specific Tips

- **Use Virtual Environments**  
  Keep dependencies isolated (`venv` or similar).

- **Admin Customization**  
  Provide user-friendly admin panels for quick data management.

- **Testing**  
  Use Django’s test framework (unittest or pytest-django) to ensure models, views, and forms work as expected.

- **Security**  
  Follow recommended security practices (CSRF protection, XSS sanitization, etc.).

---

## 5. React & Next.js Best Practices

### 5.1 Component Architecture

- **Use Functional Components**  
  Combine with TypeScript interfaces for props.

- **Define Components with the Function Keyword**  
  Clear structure and naming (e.g., `function UserProfile() {}`).

- **Extract Reusable Logic**  
  Prefer custom hooks for repeated logic.

- **Composition**  
  Build large features by composing smaller, focused components.

- **React.memo**  
  Optimize performance when re-renders are expensive.

- **Cleanup**  
  Avoid memory leaks in `useEffect` hooks with proper cleanup.

### 5.2 Performance Optimization

- **useCallback**  
  Memoize callback functions to avoid unnecessary re-renders.

- **useMemo**  
  Cache expensive computations.

- **Avoid Inline Functions in JSX**  
  Define them outside the render method.

- **Code Splitting**  
  Dynamically import heavy components to reduce initial bundle size.

- **Keys in Lists**  
  Use stable identifiers, not array indices.

---

## 6. UI and Styling (shadcn/ui + Tailwind)

### 6.1 shadcn/ui Integration

- **shadcn/ui as Primary Library**  
  Provides consistent, accessible UI patterns based on Radix UI primitives.

- **Custom Components**  
  If shadcn/ui lacks a component, create your own or use Radix UI primitives directly.

### 6.2 Tailwind CSS Guidelines

- **Utility-First**  
  Write minimal custom CSS; rely on Tailwind classes.

- **Mobile-First**  
  Start with small screens, then scale up.

- **Dark Mode**  
  Use Tailwind’s `dark:` variant or custom CSS variables for theming.

- **Accessibility**  
  Maintain proper color contrast and semantic HTML.

- **Consistent Spacing & Theming**  
  Keep design tokens for spacing, colors, and breakpoints consistent across the project.

---

## 7. State Management

### 7.1 Local State (Frontend)

- **useState**  
  For simple, isolated state in components.

- **useReducer**  
  For complex state logic or multiple transitions.

- **useContext**  
  Share state among multiple components without heavier libraries.

### 7.2 Global State (Frontend)

- **Redux Toolkit**  
  Use `createSlice` for a concise, structured approach.

- **Feature-Based Slices**  
  Organize slices by domain (e.g., `userSlice`, `cartSlice`).

- **Normalization**  
  Store data in a flat structure for easier updates.

- **Selectors**  
  Encapsulate access logic; keep code DRY.

---

## 8. Error Handling and Validation

### 8.1 Django Backend

- **Forms & Model Validation**  
  Use Django’s `forms` and model validators for robust backend checks.

- **Try/Except Blocks**  
  Catch exceptions to handle errors gracefully.

- **HTTP Status Codes**  
  Return appropriate status responses (e.g., `400`, `404`, `500`).

### 8.2 React Frontend

- **Form Validation**  
  Use libraries like **Zod** with **React Hook Form** or handle inline validations.

- **Error Boundaries**  
  Catch runtime errors in React without crashing the entire app.

- **User-Friendly Messages**  
  Inform the user when something goes wrong, rather than failing silently.

---

## 9. Testing

### 9.1 Django Testing

- **Unit Tests**  
  Validate models, views, and custom logic.

- **Integration Tests**  
  Check that combined components (models, views, URLs) behave correctly.

- **Fixtures & Factories**  
  Speed up test setup with sample data.

### 9.2 Frontend Testing

- **Jest & React Testing Library**  
  Standard stack for testing React components and logic.

- **Arrange-Act-Assert**  
  Keep your tests clean and organized.

- **Mock External Dependencies**  
  Isolate test logic from network or backend calls.

- **Integration Testing**  
  Validate user flows, focusing on how components interact.

---

## 10. Accessibility (a11y)

- **Semantic HTML & WAI-ARIA**  
  Use appropriate tags and attributes in both Django templates and Next.js components.

- **Keyboard Navigation**  
  Ensure interactive elements can be accessed via Tab keys.

- **Color Contrast**  
  Meet WCAG guidelines for legibility.

- **Heading Hierarchy**  
  Maintain clarity for screen readers.

- **Form Labels & Errors**  
  Provide descriptive error messages and labels.

---

## 11. Security

### 11.1 Django

- **CSRF Protection**  
  Use Django’s CSRF middleware for form submissions.

- **XSS & SQL Injection**  
  Use Django’s templating engine, parameterized queries, and sanitization.

- **Authentication & Permissions**  
  Rely on Django’s built-in `User` model and `Group`/`Permission` system for out-of-the-box role-based permissions.

