# Comprehensive Guide for a Django (Backend) + Next.js (Frontend) + shadcn/ui Full-Stack Project

A guide to building a modern full-stack application using **Django** (Python) on the backend and **Next.js** with **shadcn/ui** on the frontend. This document integrates established best practices from Django, React, TypeScript, Redux, and general software engineering principles.

---

## 1. Development Philosophy

- **Write Clean and Maintainable Code**  
  Keep your codebase organized and readable in both Django and Next.js.

- **Follow SOLID Principles**  
  Ensure each part of your system (backend or frontend) is modular and easy to extend.

- **Separate Concerns**  
  Let Django handle backend logic (data models, authentication, etc.) while Next.js + shadcn/ui focuses on the frontend.

- **Emphasize Type Safety**  
  For the frontend, leverage TypeScript to reduce runtime errors.

- **Component-Driven Development**  
  In the frontend, design reusable components using shadcn/ui and React.

---

## 2. Code Implementation Guidelines

### 2.1 Planning Phase

- **Step-by-Step Planning**  
  Break down each feature: consider the backend models, API endpoints, and frontend components.

- **Detailed Pseudocode**  
  Outline business logic on the Django side and data flow on the React side before implementing.

- **Document Architecture**  
  Create a clear mental model of how data flows from the Django backend to the Next.js frontend.

- **Consider Edge Cases**  
  Handle errors gracefully in both the Python backend (exceptions, validations) and the React frontend (component-level error states).

### 2.2 Code Style

#### Python (Django) Code Style

- **Follow PEP 8**
  - snake_case for variable and function names.
  - PascalCase for classes.
  - UPPERCASE for constants.
- **Use 4 Spaces for Indentation**  
  Standard for Python.
- **Line Length**  
  Aim for 79–100 characters per line (PEP 8 suggests 79).
- **Organize Imports**  
  Use `isort` or manually group imports (standard library, third-party, local) for clarity.

#### JavaScript/TypeScript (Next.js + shadcn/ui) Code Style

- **Indentation**  
  Use tabs (or 2 spaces if your team prefers—just be consistent).
- **Strings**  
  Use single quotes (avoid escaping unless necessary).
- **Semicolons**  
  Omit unless required for disambiguation.
- **Unused Variables**  
  Eliminate them—keep code clean.
- **Spacing**
  - Space after keywords, around operators, and after commas.
  - Keep `else` on the same line as closing braces.
- **Equality**  
  Always use strict equality (`===`).
- **Line Length**  
  Keep to around 80 characters when possible.
- **Trailing Commas**  
  Use trailing commas in multiline objects, arrays, and imports.

---

## 3. Naming Conventions

### 3.1 Django (Python)

- Project/App Names: lower_snake
- Model Names: PascalCase
- Field Names: snake_case
- Class-based Views: PascalCase
- Function-based Views: snake_case
- URL Names: snake_case
- Template Names: lower_snake
- Settings: UPPER_SNAKE

### 3.2 Next.js + shadcn/ui (JavaScript/TypeScript)

- Directory Names: lower_snake
- Component Names: PascalCase
- File Names: PascalCase
- Variables/Functions: camelCase
- Props/State: camelCase
- Custom Hooks: usePrefix
- CSS (Tailwind): kebab-case
- shadcn/ui Components: PascalCase
- Environment Variables: UPPER_SNAKE

---

## 4. Django Best Practices

### 4.1 Project Structure

- **Apps**  
  Each Django app should have a clear responsibility (e.g., `users`, `products`, `orders`).

- **Models**  
  Keep them concise; each model should represent a single entity.

- **Views**  
  Keep logic minimal—use services/helpers to handle complex business logic.

- **URLs**  
  Group related endpoints by app; use `include` to keep routing organized.

### 4.2 Django-Specific Tips

- **Use Virtual Environments**  
  Keep dependencies isolated (`venv` or similar).

- **Admin Customization**  
  Provide user-friendly admin panels for quick data management.

- **Testing**  
  Use Django’s test framework (unittest or pytest-django) to ensure models, views, and forms work as expected.

- **Security**  
  Follow recommended security practices (CSRF protection, XSS sanitization, etc.).

---

## 5. React & Next.js Best Practices

### 5.1 Component Architecture

- **Use Functional Components**  
  Combine with TypeScript interfaces for props.

- **Define Components with the Function Keyword**  
  Clear structure and naming (e.g., `function UserProfile() {}`).

- **Extract Reusable Logic**  
  Prefer custom hooks for repeated logic.

- **Composition**  
  Build large features by composing smaller, focused components.

- **React.memo**  
  Optimize performance when re-renders are expensive.

- **Cleanup**  
  Avoid memory leaks in `useEffect` hooks with proper cleanup.

### 5.2 Performance Optimization

- **useCallback**  
  Memoize callback functions to avoid unnecessary re-renders.

- **useMemo**  
  Cache expensive computations.

- **Avoid Inline Functions in JSX**  
  Define them outside the render method.

- **Code Splitting**  
  Dynamically import heavy components to reduce initial bundle size.

- **Keys in Lists**  
  Use stable identifiers, not array indices.

---

## 6. UI and Styling (shadcn/ui + Tailwind)

### 6.1 shadcn/ui Integration

- **shadcn/ui as Primary Library**  
  Provides consistent, accessible UI patterns based on Radix UI primitives.

- **Custom Components**  
  If shadcn/ui lacks a component, create your own or use Radix UI primitives directly.

### 6.2 Tailwind CSS Guidelines

- **Utility-First**  
  Write minimal custom CSS; rely on Tailwind classes.

- **Mobile-First**  
  Start with small screens, then scale up.

- **Dark Mode**  
  Use Tailwind’s `dark:` variant or custom CSS variables for theming.

- **Accessibility**  
  Maintain proper color contrast and semantic HTML.

- **Consistent Spacing & Theming**  
  Keep design tokens for spacing, colors, and breakpoints consistent across the project.

---

## 7. State Management

### 7.1 Local State (Frontend)

- **useState**  
  For simple, isolated state in components.

- **useReducer**  
  For complex state logic or multiple transitions.

- **useContext**  
  Share state among multiple components without heavier libraries.

### 7.2 Global State (Frontend)

- **Redux Toolkit**  
  Use `createSlice` for a concise, structured approach.

- **Feature-Based Slices**  
  Organize slices by domain (e.g., `userSlice`, `cartSlice`).

- **Normalization**  
  Store data in a flat structure for easier updates.

- **Selectors**  
  Encapsulate access logic; keep code DRY.

---

## 8. Error Handling and Validation

### 8.1 Django Backend

- **Forms & Model Validation**  
  Use Django’s `forms` and model validators for robust backend checks.

- **Try/Except Blocks**  
  Catch exceptions to handle errors gracefully.

- **HTTP Status Codes**  
  Return appropriate status responses (e.g., `400`, `404`, `500`).

### 8.2 React Frontend

- **Form Validation**  
  Use libraries like **Zod** with **React Hook Form** or handle inline validations.

- **Error Boundaries**  
  Catch runtime errors in React without crashing the entire app.

- **User-Friendly Messages**  
  Inform the user when something goes wrong, rather than failing silently.

---

## 9. Testing

### 9.1 Django Testing

- **Unit Tests**  
  Validate models, views, and custom logic.

- **Integration Tests**  
  Check that combined components (models, views, URLs) behave correctly.

- **Fixtures & Factories**  
  Speed up test setup with sample data.

### 9.2 Frontend Testing

- **Jest & React Testing Library**  
  Standard stack for testing React components and logic.

- **Arrange-Act-Assert**  
  Keep your tests clean and organized.

- **Mock External Dependencies**  
  Isolate test logic from network or backend calls.

- **Integration Testing**  
  Validate user flows, focusing on how components interact.

### End-to-End Testing

- **Playwright**  
  For true end-to-end coverage, utilize Playwright to automate real browsers (Chromium, Firefox, and WebKit). This allows you to test full user journeys—covering actual UI rendering, network calls, and cross-browser behavior—ensuring your application behaves consistently in production-like conditions.

---

## 10. Accessibility (a11y)

- **Semantic HTML & WAI-ARIA**  
  Use appropriate tags and attributes in both Django templates and Next.js components.

- **Keyboard Navigation**  
  Ensure interactive elements can be accessed via Tab keys.

- **Color Contrast**  
  Meet WCAG guidelines for legibility.

- **Heading Hierarchy**  
  Maintain clarity for screen readers.

- **Form Labels & Errors**  
  Provide descriptive error messages and labels.

---

## 11. Security

### 11.1 Django

- **CSRF Protection**  
  Use Django’s CSRF middleware for form submissions.

- **XSS & SQL Injection**  
  Use Django’s templating engine, parameterized queries, and sanitization.

- **Authentication & Permissions**  
  Rely on Django’s built-in `User` model and `Group`/`Permission` system for out-of-the-box role-based permissions.

#### 11.1.1 Best User Permission Approach for Large ERP (100+ Apps)

- **Built-in Auth System + Extensions**  
  For a large ERP with 100 modules, Django’s built-in `auth` system (with `User`, `Group`, and `Permission` models) is reliable, stable, and well-tested.

  - **Groups for Roles**: Organize users into groups representing roles (e.g., `Admin`, `Manager`, `Staff`) and assign corresponding permissions.
  - **Custom Permissions**: Define granular permissions per app/module (e.g., `can_view_reports`, `can_approve_orders`), then assign them to the appropriate groups.
  - **Extensions for Complex Cases**: If you need advanced object-level permissions, integrate libraries like **django-guardian** or **django-rules**. These allow more fine-grained controls without losing the benefits of Django’s core authentication framework.

- **Advantages**

  - Seamlessly integrates with Django Admin.
  - Easy to extend or override the `User` model.
  - Large community support and documentation.

- **Implementation Tip**
  - Start with the built-in system for broad role-based permission control.
  - Only add complexity (like object-level permission checks) if your project truly needs it.

### 11.2 Next.js

- **Safe Rendering**  
  Avoid `dangerouslySetInnerHTML`; sanitize any HTML input if absolutely necessary.

- **HTTPS**  
  Always use secure connections in production.

- **Environment Variables**  
  Keep secrets out of version control.

---

## 12. Internationalization (i18n)

- **Django i18n**  
  Use built-in localization frameworks for translations in templates and Python code.

- **next-i18next**  
  For localizing React components and routes.

- **Date & Number Formatting**  
  Ensure correct formats for each locale.

- **RTL Support**  
  Consider direction changes for right-to-left languages.

---

## 13. Documentation

- **Django Docstrings & Comments**  
  Follow Python docstring conventions for functions, classes, and modules.

- **JSDoc (Next.js + TypeScript)**  
  Document public functions, components, and hooks.

- **Markdown Formatting**  
  Use headings, lists, and links for clarity in README files or wikis.

- **Examples**  
  Provide sample code where helpful.

---

## 14. Implementation, Corrections, and Maintenance

- **Minimal, Targeted Updates**  
  Fix issues without removing existing features or altering stable routes.

- **Feature Preservation**  
  If something is broken, **modify** it to be functional rather than removing it.

- **Stability + New Features**  
  Keep existing functionality intact while adding new capabilities.

- **Single Responsibility Principle**  
  Keep components, classes, and modules focused on one responsibility.

- **Readability & Maintainability**  
  Write code that’s easy to follow and maintain, in both Django and Next.js.

- **Operating Environment**  
  Tested on **Windows 11**, but also ensure cross-platform compatibility (Linux, macOS).

---
